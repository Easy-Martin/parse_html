{"version":3,"file":"parse_html.es.js","sources":["../lib/parse_html.ts"],"sourcesContent":["// 定义核心接口：扩展属性对象（包含内部使用的styleObj）\ninterface IAttributeData {\n  [key: string]: string | Record<string, string> | undefined; // 允许值是字符串、样式对象或undefined\n  styleObj?: Record<string, string>; // 新增：显式声明styleObj属性（可选）\n}\n\n// 定义核心接口：节点数据结构（解析后的原始数据）\ninterface INodeData {\n  tagName: string; // #text | #fragment | 标签名（如div/p）\n  textContent: string;\n  attributes: IAttributeData; // 修改：使用扩展后的属性接口\n  styles: Record<string, string>; // 样式键值对（驼峰格式）\n  children: INodeData[];\n  parent: INodeData | null;\n}\n\n// 自闭合标签常量（只读数组）\nconst SELF_CLOSING_TAGS: readonly string[] = [\"img\", \"br\", \"input\", \"meta\", \"link\", \"hr\", \"area\", \"base\", \"col\", \"embed\", \"param\", \"source\", \"track\", \"wbr\"];\n\n// 工具函数：驼峰转短横线（用于样式属性）\nfunction camelToKebab(str: string): string {\n  return str.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n}\n\n// 工具函数：短横线转驼峰（用于样式属性）\nfunction kebabToCamel(str: string): string {\n  return str.replace(/-([a-z])/g, (_: string, match: string) => match.toUpperCase());\n}\n\n// 工具函数：解析属性字符串为属性对象（修改返回类型为IAttributeData）\nfunction parseAttributes(attrStr: string): IAttributeData {\n  const attrs: IAttributeData = {}; // 修改：使用扩展后的属性接口\n  if (!attrStr) return attrs;\n\n  // 匹配属性键值对：key=\"value\" / key='value' / key=value\n  const attrRegex = /([a-zA-Z0-9-]+)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\s>]+))/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = attrRegex.exec(attrStr)) !== null) {\n    const [, key, doubleVal, singleVal, noQuoteVal] = match;\n    const value = doubleVal || singleVal || noQuoteVal || \"\";\n    attrs[key] = value;\n  }\n\n  // 解析style属性为样式对象（内部属性，不对外输出）\n  if (attrs.style) {\n    const styleObj: Record<string, string> = {};\n    const styleRegex = /([a-zA-Z0-9-]+)\\s*:\\s*([^;]+)/g;\n    let styleMatch: RegExpExecArray | null;\n\n    while ((styleMatch = styleRegex.exec(attrs.style as string)) !== null) {\n      const [, prop, val] = styleMatch;\n      styleObj[kebabToCamel(prop.trim())] = val.trim();\n    }\n\n    attrs.styleObj = styleObj; // 现在类型匹配，无TS错误\n    delete attrs.style; // 替换为结构化的样式对象\n  }\n\n  return attrs;\n}\n\n// 核心工具函数：解析单个节点（内部使用）\nfunction parseSingleNode(html: string): INodeData | null {\n  html = html.trim();\n  if (!html) return null;\n\n  // 文本节点（非标签内容）\n  if (!html.startsWith(\"<\")) {\n    return {\n      tagName: \"#text\",\n      textContent: html,\n      attributes: {}, // 符合IAttributeData类型\n      styles: {},\n      children: [],\n      parent: null,\n    };\n  }\n\n  const selfClosingRegex = /<([a-zA-Z0-9]+)\\s*(.*?)\\/?>/;\n  const selfClosingMatch = html.match(selfClosingRegex);\n\n  // 处理自闭合标签\n  if (selfClosingMatch) {\n    const [, tagName, attrStr] = selfClosingMatch;\n    if (SELF_CLOSING_TAGS.includes(tagName.toLowerCase())) {\n      const attrs = parseAttributes(attrStr);\n      return {\n        tagName: tagName.toLowerCase(),\n        attributes: attrs, // 类型匹配\n        styles: attrs.styleObj || {}, // styleObj是Record<string, string>，符合styles类型\n        textContent: \"\",\n        children: [],\n        parent: null,\n      };\n    }\n  }\n\n  // 匹配开始标签\n  const startTagRegex = /<([a-zA-Z0-9]+)\\s*(.*?)>/;\n  const startTagMatch = html.match(startTagRegex);\n  if (!startTagMatch) return null;\n\n  const [startTag, tagName, attrStr] = startTagMatch;\n  const lowerTagName = tagName.toLowerCase();\n  const endTag = `</${lowerTagName}>`;\n\n  // 查找匹配的结束标签（处理嵌套）\n  let endTagIndex = -1;\n  let tagCount = 1;\n  let currentIndex = startTag.length;\n\n  while (currentIndex < html.length && tagCount > 0) {\n    const nextStart = html.indexOf(`<${lowerTagName}`, currentIndex);\n    const nextEnd = html.indexOf(endTag, currentIndex);\n\n    if (nextEnd === -1) break;\n    if (nextStart !== -1 && nextStart < nextEnd) {\n      tagCount++;\n      currentIndex = nextStart + `<${lowerTagName}`.length;\n    } else {\n      tagCount--;\n      if (tagCount === 0) endTagIndex = nextEnd;\n      currentIndex = nextEnd + endTag.length;\n    }\n  }\n\n  // 提取标签内容（开始标签和结束标签之间）\n  const content = endTagIndex !== -1 ? html.slice(startTag.length, endTagIndex).trim() : html.slice(startTag.length).trim();\n\n  // 构建基础节点数据\n  const attrs = parseAttributes(attrStr);\n  const nodeData: INodeData = {\n    tagName: lowerTagName,\n    attributes: attrs, // 类型匹配\n    styles: attrs.styleObj || {}, // 类型匹配\n    textContent: \"\",\n    children: [],\n    parent: null,\n  };\n\n  // 解析子节点\n  if (content) {\n    const childNodes: INodeData[] = [];\n    let remaining = content;\n\n    while (remaining) {\n      const tagStart = remaining.indexOf(\"<\");\n      if (tagStart === -1) {\n        // 纯文本内容\n        const textNode = parseSingleNode(remaining);\n        if (textNode) childNodes.push(textNode);\n        remaining = \"\";\n      } else {\n        if (tagStart > 0) {\n          // 标签前的文本\n          const textNode = parseSingleNode(remaining.slice(0, tagStart));\n          if (textNode) childNodes.push(textNode);\n          remaining = remaining.slice(tagStart);\n        } else {\n          // 解析嵌套标签\n          const tempTagMatch = remaining.match(startTagRegex);\n          if (!tempTagMatch) {\n            const textNode = parseSingleNode(remaining);\n            if (textNode) childNodes.push(textNode);\n            remaining = \"\";\n            continue;\n          }\n\n          const tempTagName = tempTagMatch[1].toLowerCase();\n          const tempEndTag = `</${tempTagName}>`;\n\n          // 自闭合标签直接处理\n          if (SELF_CLOSING_TAGS.includes(tempTagName)) {\n            const selfNode = parseSingleNode(remaining.slice(0, tempTagMatch[0].length));\n            if (selfNode) childNodes.push(selfNode);\n            remaining = remaining.slice(tempTagMatch[0].length).trim();\n            continue;\n          }\n\n          // 查找嵌套标签的结束位置\n          let tempEndIndex = -1;\n          let tempTagCount = 1;\n          let tempCurrentIndex = tempTagMatch[0].length;\n\n          while (tempCurrentIndex < remaining.length && tempTagCount > 0) {\n            const nextTempStart = remaining.indexOf(`<${tempTagName}`, tempCurrentIndex);\n            const nextTempEnd = remaining.indexOf(tempEndTag, tempCurrentIndex);\n\n            if (nextTempEnd === -1) break;\n            if (nextTempStart !== -1 && nextTempStart < nextTempEnd) {\n              tempTagCount++;\n              tempCurrentIndex = nextTempStart + `<${tempTagName}`.length;\n            } else {\n              tempTagCount--;\n              if (tempTagCount === 0) tempEndIndex = nextTempEnd;\n              tempCurrentIndex = nextTempEnd + tempEndTag.length;\n            }\n          }\n\n          // 提取子节点HTML并递归解析\n          if (tempEndIndex !== -1) {\n            const childHTML = remaining.slice(0, tempEndIndex + tempEndTag.length);\n            const childNode = parseSingleNode(childHTML);\n            if (childNode) childNodes.push(childNode);\n            remaining = remaining.slice(tempEndIndex + tempEndTag.length).trim();\n          } else {\n            const childNode = parseSingleNode(remaining);\n            if (childNode) childNodes.push(childNode);\n            remaining = \"\";\n          }\n        }\n      }\n    }\n\n    // 过滤无效节点并赋值\n    nodeData.children = childNodes.filter(Boolean);\n    // 单一文本子节点直接合并到textContent\n    if (nodeData.children.length === 1 && nodeData.children[0].tagName === \"#text\") {\n      nodeData.textContent = nodeData.children[0].textContent;\n      nodeData.children = [];\n    }\n  }\n\n  return nodeData;\n}\n\n// 新增：解析HTML片段（支持多根节点）\nfunction parseHTMLFragment(html: string): INodeData[] {\n  html = html.trim();\n  if (!html) return [];\n\n  const fragmentNodes: INodeData[] = [];\n  let remaining = html;\n\n  while (remaining) {\n    const tagStart = remaining.indexOf(\"<\");\n    if (tagStart === -1) {\n      // 剩余纯文本\n      const textNode = parseSingleNode(remaining);\n      if (textNode) fragmentNodes.push(textNode);\n      remaining = \"\";\n    } else {\n      if (tagStart > 0) {\n        // 标签前的文本节点\n        const textNode = parseSingleNode(remaining.slice(0, tagStart));\n        if (textNode) fragmentNodes.push(textNode);\n        remaining = remaining.slice(tagStart);\n      } else {\n        // 解析单个标签节点\n        const startTagRegex = /<([a-zA-Z0-9]+)\\s*(.*?)>/;\n        const tempTagMatch = remaining.match(startTagRegex);\n\n        if (!tempTagMatch) {\n          const textNode = parseSingleNode(remaining);\n          if (textNode) fragmentNodes.push(textNode);\n          remaining = \"\";\n          continue;\n        }\n\n        const tempTagName = tempTagMatch[1].toLowerCase();\n\n        // 自闭合标签\n        if (SELF_CLOSING_TAGS.includes(tempTagName)) {\n          const selfClosingRegex = /<([a-zA-Z0-9]+)\\s*(.*?)\\/?>/;\n          const selfClosingMatch = remaining.match(selfClosingRegex);\n\n          if (selfClosingMatch) {\n            const selfNode = parseSingleNode(selfClosingMatch[0]);\n            if (selfNode) fragmentNodes.push(selfNode);\n            remaining = remaining.slice(selfClosingMatch[0].length).trim();\n          } else {\n            const textNode = parseSingleNode(remaining);\n            if (textNode) fragmentNodes.push(textNode);\n            remaining = \"\";\n          }\n        } else {\n          // 非自闭合标签，找匹配的结束标签\n          const tempEndTag = `</${tempTagName}>`;\n          let tempEndIndex = -1;\n          let tempTagCount = 1;\n          let tempCurrentIndex = tempTagMatch[0].length;\n\n          while (tempCurrentIndex < remaining.length && tempTagCount > 0) {\n            const nextTempStart = remaining.indexOf(`<${tempTagName}`, tempCurrentIndex);\n            const nextTempEnd = remaining.indexOf(tempEndTag, tempCurrentIndex);\n\n            if (nextTempEnd === -1) break;\n            if (nextTempStart !== -1 && nextTempStart < nextTempEnd) {\n              tempTagCount++;\n              tempCurrentIndex = nextTempStart + `<${tempTagName}`.length;\n            } else {\n              tempTagCount--;\n              if (tempTagCount === 0) tempEndIndex = nextTempEnd;\n              tempCurrentIndex = nextTempEnd + tempEndTag.length;\n            }\n          }\n\n          if (tempEndIndex !== -1) {\n            const childHTML = remaining.slice(0, tempEndIndex + tempEndTag.length);\n            const childNode = parseSingleNode(childHTML);\n            if (childNode) fragmentNodes.push(childNode);\n            remaining = remaining.slice(tempEndIndex + tempEndTag.length).trim();\n          } else {\n            const childNode = parseSingleNode(remaining);\n            if (childNode) fragmentNodes.push(childNode);\n            remaining = \"\";\n          }\n        }\n      }\n    }\n  }\n\n  // 过滤无效节点\n  return fragmentNodes.filter(Boolean);\n}\n\n// 核心Node类实现（支持片段/多根节点）\nclass Node {\n  public tagName: string;\n  public attributes: IAttributeData; // 修改：使用扩展后的属性接口\n  public styles: Record<string, string>;\n  public textContent: string;\n  public children: Node[];\n  public parent: Node | null;\n\n  /**\n   * 构造函数：通过HTML字符串初始化节点（支持单根/多根）\n   * @param {string} html - HTML字符串（单根/多根均可）\n   */\n  constructor(html: string) {\n    if (typeof html !== \"string\") {\n      throw new Error(\"初始化Node必须传入HTML字符串\");\n    }\n\n    const htmlTrimmed = html.trim();\n    if (!htmlTrimmed) {\n      throw new Error(\"无法解析空的HTML字符串\");\n    }\n\n    // 尝试解析为单一节点\n    const singleNodeData = parseSingleNode(htmlTrimmed);\n    // 解析为片段（多根节点）\n    const fragmentNodeData = parseHTMLFragment(htmlTrimmed);\n\n    // 初始化默认属性\n    this.tagName = \"\";\n    this.attributes = {}; // 符合IAttributeData类型\n    this.styles = {};\n    this.textContent = \"\";\n    this.children = [];\n    this.parent = null;\n\n    // 节点核心属性赋值\n    if (singleNodeData && fragmentNodeData.length === 1) {\n      // 单根节点\n      this.tagName = singleNodeData.tagName;\n      this.attributes = { ...singleNodeData.attributes };\n      this.styles = { ...singleNodeData.styles };\n      this.textContent = singleNodeData.textContent || \"\";\n\n      // 子节点转换为Node实例\n      if (singleNodeData.children.length > 0) {\n        this.children = singleNodeData.children.map((childData) => {\n          const childNode = new Node(this.#generateHTMLFromData(childData));\n          childNode.parent = this;\n          return childNode;\n        });\n      }\n    } else if (fragmentNodeData.length > 0) {\n      // 多根节点 → 标记为片段节点\n      this.tagName = \"#fragment\";\n      this.attributes = {}; // 符合IAttributeData类型\n      this.styles = {};\n      this.textContent = \"\";\n\n      // 片段的子节点是多个根节点\n      this.children = fragmentNodeData.map((childData) => {\n        const childNode = new Node(this.#generateHTMLFromData(childData));\n        childNode.parent = this;\n        return childNode;\n      });\n    } else {\n      throw new Error(\"无法解析无效的HTML字符串\");\n    }\n  }\n\n  /**\n   * 私有方法：从节点数据生成HTML字符串（用于子节点初始化）\n   * @param {INodeData} nodeData - 节点数据\n   * @returns {string} HTML字符串\n   */\n  #generateHTMLFromData(nodeData: INodeData): string {\n    if (nodeData.tagName === \"#text\") return nodeData.textContent;\n\n    // 构建开始标签\n    let startTag = `<${nodeData.tagName}`;\n    const attrs = { ...nodeData.attributes };\n\n    // 拼接样式属性（覆盖原始style）\n    if (Object.keys(nodeData.styles).length > 0) {\n      const styleStr = Object.entries(nodeData.styles)\n        .map(([key, val]) => `${camelToKebab(key)}: ${val}`)\n        .join(\"; \");\n      attrs.style = styleStr;\n    }\n\n    // 拼接所有属性：过滤内部属性styleObj\n    for (const [key, val] of Object.entries(attrs)) {\n      if (key === \"styleObj\") continue; // 核心修复：跳过内部样式对象属性\n      // 确保val是字符串（IAttributeData中除了styleObj都是string）\n      if (typeof val === \"string\") {\n        startTag += ` ${key}=\"${val}\"`;\n      }\n    }\n\n    // 自闭合标签处理\n    if (SELF_CLOSING_TAGS.includes(nodeData.tagName)) {\n      startTag += \"/>\";\n      return startTag;\n    }\n\n    startTag += \">\";\n\n    // 拼接内容（文本+子节点）\n    let content = nodeData.textContent;\n    if (nodeData.children.length > 0) {\n      content += nodeData.children.map((child) => this.#generateHTMLFromData(child)).join(\"\");\n    }\n\n    return `${startTag}${content}</${nodeData.tagName}>`;\n  }\n\n  /**\n   * 子集管理：获取当前节点的所有子节点\n   * @returns {Node[]} 子节点数组（浅拷贝）\n   */\n  child(): Node[] {\n    return [...this.children];\n  }\n\n  /**\n   * DOM操作：在当前节点之后插入新元素\n   * @param {string|Node} newNode - 要插入的HTML字符串或Node实例\n   * @returns {Node} 当前节点（链式调用）\n   */\n  before(newNode: string | Node): Node {\n    if (!this.parent) {\n      throw new Error(\"当前节点没有父节点，无法执行before操作\");\n    }\n\n    const nodeToInsert = this.#convertToNode(newNode);\n    const currentIndex = this.parent.children.findIndex((child) => child === this);\n\n    if (currentIndex === -1) {\n      throw new Error(\"当前节点不在父节点的子节点列表中\");\n    }\n\n    // 插入到当前节点前一个位置\n    this.parent.children.splice(currentIndex, 0, nodeToInsert);\n    nodeToInsert.parent = this.parent;\n\n    return this;\n  }\n\n  /**\n   * DOM操作：在当前节点之后插入新元素\n   * @param {string|Node} newNode - 要插入的HTML字符串或Node实例\n   * @returns {Node} 当前节点（链式调用）\n   */\n  after(newNode: string | Node): Node {\n    if (!this.parent) {\n      throw new Error(\"当前节点没有父节点，无法执行after操作\");\n    }\n\n    const nodeToInsert = this.#convertToNode(newNode);\n    const currentIndex = this.parent.children.findIndex((child) => child === this);\n\n    if (currentIndex === -1) {\n      throw new Error(\"当前节点不在父节点的子节点列表中\");\n    }\n\n    // 插入到当前节点下一个位置\n    this.parent.children.splice(currentIndex + 1, 0, nodeToInsert);\n    nodeToInsert.parent = this.parent;\n\n    return this;\n  }\n\n  /**\n   * DOM操作：在指定位置插入新元素\n   * @param {number} position - 插入位置（0 ~ children.length）\n   * @param {string|Node} newNode - 要插入的HTML字符串或Node实例\n   * @returns {Node} 当前节点（链式调用）\n   */\n  insert(position: number, newNode: string | Node): Node {\n    if (typeof position !== \"number\" || position < 0 || position > this.children.length) {\n      throw new Error(`插入位置${position}无效，必须是0到${this.children.length}之间的整数`);\n    }\n\n    const nodeToInsert = this.#convertToNode(newNode);\n    // 如果插入的是片段节点，展开其所有子节点（符合DOM标准）\n    if (nodeToInsert.tagName === \"#fragment\") {\n      nodeToInsert.children.forEach((child, index) => {\n        child.parent = this;\n        this.children.splice(position + index, 0, child);\n      });\n    } else {\n      this.children.splice(position, 0, nodeToInsert);\n      nodeToInsert.parent = this;\n    }\n\n    return this;\n  }\n\n  /**\n   * 属性操作：获取指定属性的值\n   * @param {string} attrName - 属性名\n   * @returns {string|null} 属性值（不存在返回null）\n   */\n  getAttr(attrName: string): string | null {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      return null; // 片段/文本节点无属性\n    }\n    if (typeof attrName !== \"string\") {\n      throw new Error(\"属性名必须是字符串\");\n    }\n    // 只返回字符串类型的属性（排除styleObj）\n    return typeof this.attributes[attrName] === \"string\" ? this.attributes[attrName] : null;\n  }\n\n  /**\n   * 属性操作：设置指定属性的值\n   * @param {string} attrName - 属性名\n   * @param {string|null|undefined} value - 属性值（null/undefined删除属性）\n   * @returns {Node} 当前节点（链式调用）\n   */\n  setAttr(attrName: string, value: string | null | undefined): Node {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      throw new Error(\"片段/文本节点不支持设置属性\");\n    }\n    if (typeof attrName !== \"string\") {\n      throw new Error(\"属性名必须是字符串\");\n    }\n\n    if (value === null || value === undefined) {\n      delete this.attributes[attrName];\n    } else {\n      // 确保属性值是字符串（符合IAttributeData的基础约束）\n      this.attributes[attrName] = String(value);\n    }\n\n    return this;\n  }\n\n  /**\n   * 属性操作：批量设置多个属性\n   * @param {Record<string, string | null | undefined>} attrs - 包含属性名-属性值键值对的对象\n   * @returns {Node} 当前节点（链式调用）\n   */\n  setAttrs(attrs: Record<string, string | null | undefined>): Node {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      throw new Error(\"片段/文本节点不支持设置属性\");\n    }\n    if (typeof attrs !== \"object\" || attrs === null) {\n      throw new Error(\"属性对象必须是非空对象\");\n    }\n\n    for (const [attrName, value] of Object.entries(attrs)) {\n      this.setAttr(attrName, value);\n    }\n\n    return this;\n  }\n\n  /**\n   * 样式操作：获取指定样式属性的值\n   * @param {string} styleProp - 样式属性名（支持驼峰/短横线）\n   * @returns {string|null} 样式值（不存在返回null）\n   */\n  getStyle(styleProp: string): string | null {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      return null; // 片段/文本节点无样式\n    }\n    if (typeof styleProp !== \"string\") {\n      throw new Error(\"样式属性名必须是字符串\");\n    }\n\n    const camelProp = kebabToCamel(styleProp);\n    return this.styles[camelProp] || this.styles[styleProp] || null;\n  }\n\n  /**\n   * 样式操作：设置指定样式属性的值\n   * @param {string} styleProp - 样式属性名（支持驼峰/短横线）\n   * @param {string|null|undefined} value - 样式值（null/undefined删除样式）\n   * @returns {Node} 当前节点（链式调用）\n   */\n  setStyle(styleProp: string, value: string | null | undefined): Node {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      throw new Error(\"片段/文本节点不支持设置样式\");\n    }\n    if (typeof styleProp !== \"string\") {\n      throw new Error(\"样式属性名必须是字符串\");\n    }\n\n    const camelProp = kebabToCamel(styleProp);\n    if (value === null || value === undefined) {\n      delete this.styles[camelProp];\n      delete this.styles[styleProp];\n    } else {\n      this.styles[camelProp] = String(value);\n    }\n\n    return this;\n  }\n\n  /**\n   * 样式操作：批量设置多个样式属性\n   * @param {Record<string, string | null | undefined>} styles - 包含样式属性名-样式值键值对的对象\n   * @returns {Node} 当前节点（链式调用）\n   */\n  setStyles(styles: Record<string, string | null | undefined>): Node {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      throw new Error(\"片段/文本节点不支持设置样式\");\n    }\n    if (typeof styles !== \"object\" || styles === null) {\n      throw new Error(\"样式对象必须是非空对象\");\n    }\n\n    for (const [styleProp, value] of Object.entries(styles)) {\n      this.setStyle(styleProp, value);\n    }\n\n    return this;\n  }\n\n  /**\n   * 获取当前节点的完整HTML文本\n   * @returns {string} HTML字符串\n   */\n  getHtml(): string {\n    // 文本节点直接返回文本\n    if (this.tagName === \"#text\") {\n      return this.textContent;\n    }\n\n    // 片段节点返回所有子节点的HTML拼接\n    if (this.tagName === \"#fragment\") {\n      return this.children.map((child) => child.getHtml()).join(\"\");\n    }\n\n    // 普通元素节点\n    let startTag = `<${this.tagName}`;\n    const attrs = { ...this.attributes };\n\n    // 拼接样式属性（覆盖原始style）\n    if (Object.keys(this.styles).length > 0) {\n      const styleStr = Object.entries(this.styles)\n        .map(([key, val]) => `${camelToKebab(key)}: ${val}`)\n        .join(\"; \");\n      attrs.style = styleStr;\n    }\n\n    // 拼接所有属性：过滤内部属性styleObj，确保值是字符串\n    for (const [key, val] of Object.entries(attrs)) {\n      if (key === \"styleObj\") continue; // 核心修复：跳过内部样式对象属性\n      if (typeof val === \"string\") {\n        const safeVal = val.replace(/\"/g, \"&quot;\");\n        startTag += ` ${key}=\"${safeVal}\"`;\n      }\n    }\n\n    // 自闭合标签处理\n    if (SELF_CLOSING_TAGS.includes(this.tagName)) {\n      startTag += \"/>\";\n      return startTag;\n    }\n\n    startTag += \">\";\n\n    // 拼接内容（文本+子节点HTML）\n    let content = this.textContent;\n    if (this.children.length > 0) {\n      content += this.children.map((child) => child.getHtml()).join(\"\");\n    }\n\n    return `${startTag}${content}</${this.tagName}>`;\n  }\n\n  /**\n   * 私有辅助方法：统一转换插入的节点为Node实例\n   * @param {string|Node} node - HTML字符串或Node实例\n   * @returns {Node} Node实例\n   */\n  #convertToNode(node: string | Node): Node {\n    if (node instanceof Node) return node;\n    if (typeof node === \"string\") return new Node(node);\n    throw new Error(\"插入的节点必须是HTML字符串或Node实例\");\n  }\n}\n\nexport default Node;\n"],"names":["SELF_CLOSING_TAGS","camelToKebab","str","match","kebabToCamel","_","parseAttributes","attrStr","attrs","attrRegex","key","doubleVal","singleVal","noQuoteVal","value","styleObj","styleRegex","styleMatch","prop","val","parseSingleNode","html","selfClosingRegex","selfClosingMatch","tagName","startTagRegex","startTagMatch","startTag","lowerTagName","endTag","endTagIndex","tagCount","currentIndex","nextStart","nextEnd","content","nodeData","childNodes","remaining","tagStart","textNode","tempTagMatch","tempTagName","tempEndTag","selfNode","tempEndIndex","tempTagCount","tempCurrentIndex","nextTempStart","nextTempEnd","childHTML","childNode","parseHTMLFragment","fragmentNodes","Node","htmlTrimmed","singleNodeData","fragmentNodeData","childData","#generateHTMLFromData","styleStr","child","newNode","nodeToInsert","#convertToNode","position","index","attrName","styleProp","camelProp","styles","safeVal","node"],"mappings":"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"}