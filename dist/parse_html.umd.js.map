{"version":3,"file":"parse_html.umd.js","sources":["../lib/parse_html.ts"],"sourcesContent":["// 定义核心接口：扩展属性对象（包含内部使用的styleObj）\ninterface IAttributeData {\n  [key: string]: string | Record<string, string> | undefined; // 允许值是字符串、样式对象或undefined\n  styleObj?: Record<string, string>; // 新增：显式声明styleObj属性（可选）\n}\n\n// 定义核心接口：节点数据结构（解析后的原始数据）\ninterface INodeData {\n  tagName: string; // #text | #fragment | 标签名（如div/p）\n  textContent: string;\n  attributes: IAttributeData; // 修改：使用扩展后的属性接口\n  styles: Record<string, string>; // 样式键值对（驼峰格式）\n  children: INodeData[];\n  parent: INodeData | null;\n}\n\n// 自闭合标签常量（只读数组）\nconst SELF_CLOSING_TAGS: readonly string[] = [\"img\", \"br\", \"input\", \"meta\", \"link\", \"hr\", \"area\", \"base\", \"col\", \"embed\", \"param\", \"source\", \"track\", \"wbr\"];\n\n// 工具函数：驼峰转短横线（用于样式属性）\nfunction camelToKebab(str: string): string {\n  return str.replace(/[A-Z]/g, (match) => `-${match.toLowerCase()}`);\n}\n\n// 工具函数：短横线转驼峰（用于样式属性）\nfunction kebabToCamel(str: string): string {\n  return str.replace(/-([a-z])/g, (_: string, match: string) => match.toUpperCase());\n}\n\n// 工具函数：解析属性字符串为属性对象（修改返回类型为IAttributeData）\nfunction parseAttributes(attrStr: string): IAttributeData {\n  const attrs: IAttributeData = {}; // 修改：使用扩展后的属性接口\n  if (!attrStr) return attrs;\n\n  // 匹配属性键值对：key=\"value\" / key='value' / key=value\n  const attrRegex = /([a-zA-Z0-9-]+)\\s*=\\s*(?:\"([^\"]*)\"|'([^']*)'|([^\\s>]+))/g;\n  let match: RegExpExecArray | null;\n\n  while ((match = attrRegex.exec(attrStr)) !== null) {\n    const [, key, doubleVal, singleVal, noQuoteVal] = match;\n    const value = doubleVal || singleVal || noQuoteVal || \"\";\n    attrs[key] = value;\n  }\n\n  // 解析style属性为样式对象（内部属性，不对外输出）\n  if (attrs.style) {\n    const styleObj: Record<string, string> = {};\n    const styleRegex = /([a-zA-Z0-9-]+)\\s*:\\s*([^;]+)/g;\n    let styleMatch: RegExpExecArray | null;\n\n    while ((styleMatch = styleRegex.exec(attrs.style as string)) !== null) {\n      const [, prop, val] = styleMatch;\n      styleObj[kebabToCamel(prop.trim())] = val.trim();\n    }\n\n    attrs.styleObj = styleObj; // 现在类型匹配，无TS错误\n    delete attrs.style; // 替换为结构化的样式对象\n  }\n\n  return attrs;\n}\n\n// 核心工具函数：解析单个节点（内部使用）\nfunction parseSingleNode(html: string): INodeData | null {\n  html = html.trim();\n  if (!html) return null;\n\n  // 文本节点（非标签内容）\n  if (!html.startsWith(\"<\")) {\n    return {\n      tagName: \"#text\",\n      textContent: html,\n      attributes: {}, // 符合IAttributeData类型\n      styles: {},\n      children: [],\n      parent: null,\n    };\n  }\n\n  const selfClosingRegex = /<([a-zA-Z0-9]+)\\s*(.*?)\\/?>/;\n  const selfClosingMatch = html.match(selfClosingRegex);\n\n  // 处理自闭合标签\n  if (selfClosingMatch) {\n    const [, tagName, attrStr] = selfClosingMatch;\n    if (SELF_CLOSING_TAGS.includes(tagName.toLowerCase())) {\n      const attrs = parseAttributes(attrStr);\n      return {\n        tagName: tagName.toLowerCase(),\n        attributes: attrs, // 类型匹配\n        styles: attrs.styleObj || {}, // styleObj是Record<string, string>，符合styles类型\n        textContent: \"\",\n        children: [],\n        parent: null,\n      };\n    }\n  }\n\n  // 匹配开始标签\n  const startTagRegex = /<([a-zA-Z0-9]+)\\s*(.*?)>/;\n  const startTagMatch = html.match(startTagRegex);\n  if (!startTagMatch) return null;\n\n  const [startTag, tagName, attrStr] = startTagMatch;\n  const lowerTagName = tagName.toLowerCase();\n  const endTag = `</${lowerTagName}>`;\n\n  // 查找匹配的结束标签（处理嵌套）\n  let endTagIndex = -1;\n  let tagCount = 1;\n  let currentIndex = startTag.length;\n\n  while (currentIndex < html.length && tagCount > 0) {\n    const nextStart = html.indexOf(`<${lowerTagName}`, currentIndex);\n    const nextEnd = html.indexOf(endTag, currentIndex);\n\n    if (nextEnd === -1) break;\n    if (nextStart !== -1 && nextStart < nextEnd) {\n      tagCount++;\n      currentIndex = nextStart + `<${lowerTagName}`.length;\n    } else {\n      tagCount--;\n      if (tagCount === 0) endTagIndex = nextEnd;\n      currentIndex = nextEnd + endTag.length;\n    }\n  }\n\n  // 提取标签内容（开始标签和结束标签之间）\n  const content = endTagIndex !== -1 ? html.slice(startTag.length, endTagIndex).trim() : html.slice(startTag.length).trim();\n\n  // 构建基础节点数据\n  const attrs = parseAttributes(attrStr);\n  const nodeData: INodeData = {\n    tagName: lowerTagName,\n    attributes: attrs, // 类型匹配\n    styles: attrs.styleObj || {}, // 类型匹配\n    textContent: \"\",\n    children: [],\n    parent: null,\n  };\n\n  // 解析子节点\n  if (content) {\n    const childNodes: INodeData[] = [];\n    let remaining = content;\n\n    while (remaining) {\n      const tagStart = remaining.indexOf(\"<\");\n      if (tagStart === -1) {\n        // 纯文本内容\n        const textNode = parseSingleNode(remaining);\n        if (textNode) childNodes.push(textNode);\n        remaining = \"\";\n      } else {\n        if (tagStart > 0) {\n          // 标签前的文本\n          const textNode = parseSingleNode(remaining.slice(0, tagStart));\n          if (textNode) childNodes.push(textNode);\n          remaining = remaining.slice(tagStart);\n        } else {\n          // 解析嵌套标签\n          const tempTagMatch = remaining.match(startTagRegex);\n          if (!tempTagMatch) {\n            const textNode = parseSingleNode(remaining);\n            if (textNode) childNodes.push(textNode);\n            remaining = \"\";\n            continue;\n          }\n\n          const tempTagName = tempTagMatch[1].toLowerCase();\n          const tempEndTag = `</${tempTagName}>`;\n\n          // 自闭合标签直接处理\n          if (SELF_CLOSING_TAGS.includes(tempTagName)) {\n            const selfNode = parseSingleNode(remaining.slice(0, tempTagMatch[0].length));\n            if (selfNode) childNodes.push(selfNode);\n            remaining = remaining.slice(tempTagMatch[0].length).trim();\n            continue;\n          }\n\n          // 查找嵌套标签的结束位置\n          let tempEndIndex = -1;\n          let tempTagCount = 1;\n          let tempCurrentIndex = tempTagMatch[0].length;\n\n          while (tempCurrentIndex < remaining.length && tempTagCount > 0) {\n            const nextTempStart = remaining.indexOf(`<${tempTagName}`, tempCurrentIndex);\n            const nextTempEnd = remaining.indexOf(tempEndTag, tempCurrentIndex);\n\n            if (nextTempEnd === -1) break;\n            if (nextTempStart !== -1 && nextTempStart < nextTempEnd) {\n              tempTagCount++;\n              tempCurrentIndex = nextTempStart + `<${tempTagName}`.length;\n            } else {\n              tempTagCount--;\n              if (tempTagCount === 0) tempEndIndex = nextTempEnd;\n              tempCurrentIndex = nextTempEnd + tempEndTag.length;\n            }\n          }\n\n          // 提取子节点HTML并递归解析\n          if (tempEndIndex !== -1) {\n            const childHTML = remaining.slice(0, tempEndIndex + tempEndTag.length);\n            const childNode = parseSingleNode(childHTML);\n            if (childNode) childNodes.push(childNode);\n            remaining = remaining.slice(tempEndIndex + tempEndTag.length).trim();\n          } else {\n            const childNode = parseSingleNode(remaining);\n            if (childNode) childNodes.push(childNode);\n            remaining = \"\";\n          }\n        }\n      }\n    }\n\n    // 过滤无效节点并赋值\n    nodeData.children = childNodes.filter(Boolean);\n    // 单一文本子节点直接合并到textContent\n    if (nodeData.children.length === 1 && nodeData.children[0].tagName === \"#text\") {\n      nodeData.textContent = nodeData.children[0].textContent;\n      nodeData.children = [];\n    }\n  }\n\n  return nodeData;\n}\n\n// 新增：解析HTML片段（支持多根节点）\nfunction parseHTMLFragment(html: string): INodeData[] {\n  html = html.trim();\n  if (!html) return [];\n\n  const fragmentNodes: INodeData[] = [];\n  let remaining = html;\n\n  while (remaining) {\n    const tagStart = remaining.indexOf(\"<\");\n    if (tagStart === -1) {\n      // 剩余纯文本\n      const textNode = parseSingleNode(remaining);\n      if (textNode) fragmentNodes.push(textNode);\n      remaining = \"\";\n    } else {\n      if (tagStart > 0) {\n        // 标签前的文本节点\n        const textNode = parseSingleNode(remaining.slice(0, tagStart));\n        if (textNode) fragmentNodes.push(textNode);\n        remaining = remaining.slice(tagStart);\n      } else {\n        // 解析单个标签节点\n        const startTagRegex = /<([a-zA-Z0-9]+)\\s*(.*?)>/;\n        const tempTagMatch = remaining.match(startTagRegex);\n\n        if (!tempTagMatch) {\n          const textNode = parseSingleNode(remaining);\n          if (textNode) fragmentNodes.push(textNode);\n          remaining = \"\";\n          continue;\n        }\n\n        const tempTagName = tempTagMatch[1].toLowerCase();\n\n        // 自闭合标签\n        if (SELF_CLOSING_TAGS.includes(tempTagName)) {\n          const selfClosingRegex = /<([a-zA-Z0-9]+)\\s*(.*?)\\/?>/;\n          const selfClosingMatch = remaining.match(selfClosingRegex);\n\n          if (selfClosingMatch) {\n            const selfNode = parseSingleNode(selfClosingMatch[0]);\n            if (selfNode) fragmentNodes.push(selfNode);\n            remaining = remaining.slice(selfClosingMatch[0].length).trim();\n          } else {\n            const textNode = parseSingleNode(remaining);\n            if (textNode) fragmentNodes.push(textNode);\n            remaining = \"\";\n          }\n        } else {\n          // 非自闭合标签，找匹配的结束标签\n          const tempEndTag = `</${tempTagName}>`;\n          let tempEndIndex = -1;\n          let tempTagCount = 1;\n          let tempCurrentIndex = tempTagMatch[0].length;\n\n          while (tempCurrentIndex < remaining.length && tempTagCount > 0) {\n            const nextTempStart = remaining.indexOf(`<${tempTagName}`, tempCurrentIndex);\n            const nextTempEnd = remaining.indexOf(tempEndTag, tempCurrentIndex);\n\n            if (nextTempEnd === -1) break;\n            if (nextTempStart !== -1 && nextTempStart < nextTempEnd) {\n              tempTagCount++;\n              tempCurrentIndex = nextTempStart + `<${tempTagName}`.length;\n            } else {\n              tempTagCount--;\n              if (tempTagCount === 0) tempEndIndex = nextTempEnd;\n              tempCurrentIndex = nextTempEnd + tempEndTag.length;\n            }\n          }\n\n          if (tempEndIndex !== -1) {\n            const childHTML = remaining.slice(0, tempEndIndex + tempEndTag.length);\n            const childNode = parseSingleNode(childHTML);\n            if (childNode) fragmentNodes.push(childNode);\n            remaining = remaining.slice(tempEndIndex + tempEndTag.length).trim();\n          } else {\n            const childNode = parseSingleNode(remaining);\n            if (childNode) fragmentNodes.push(childNode);\n            remaining = \"\";\n          }\n        }\n      }\n    }\n  }\n\n  // 过滤无效节点\n  return fragmentNodes.filter(Boolean);\n}\n\n// 核心Node类实现（支持片段/多根节点）\nclass Node {\n  public tagName: string;\n  public attributes: IAttributeData; // 修改：使用扩展后的属性接口\n  public styles: Record<string, string>;\n  public textContent: string;\n  public children: Node[];\n  public parent: Node | null;\n\n  /**\n   * 构造函数：通过HTML字符串初始化节点（支持单根/多根）\n   * @param {string} html - HTML字符串（单根/多根均可）\n   */\n  constructor(html: string) {\n    if (typeof html !== \"string\") {\n      throw new Error(\"初始化Node必须传入HTML字符串\");\n    }\n\n    const htmlTrimmed = html.trim();\n    if (!htmlTrimmed) {\n      throw new Error(\"无法解析空的HTML字符串\");\n    }\n\n    // 尝试解析为单一节点\n    const singleNodeData = parseSingleNode(htmlTrimmed);\n    // 解析为片段（多根节点）\n    const fragmentNodeData = parseHTMLFragment(htmlTrimmed);\n\n    // 初始化默认属性\n    this.tagName = \"\";\n    this.attributes = {}; // 符合IAttributeData类型\n    this.styles = {};\n    this.textContent = \"\";\n    this.children = [];\n    this.parent = null;\n\n    // 节点核心属性赋值\n    if (singleNodeData && fragmentNodeData.length === 1) {\n      // 单根节点\n      this.tagName = singleNodeData.tagName;\n      this.attributes = { ...singleNodeData.attributes };\n      this.styles = { ...singleNodeData.styles };\n      this.textContent = singleNodeData.textContent || \"\";\n\n      // 子节点转换为Node实例\n      if (singleNodeData.children.length > 0) {\n        this.children = singleNodeData.children.map((childData) => {\n          const childNode = new Node(this.#generateHTMLFromData(childData));\n          childNode.parent = this;\n          return childNode;\n        });\n      }\n    } else if (fragmentNodeData.length > 0) {\n      // 多根节点 → 标记为片段节点\n      this.tagName = \"#fragment\";\n      this.attributes = {}; // 符合IAttributeData类型\n      this.styles = {};\n      this.textContent = \"\";\n\n      // 片段的子节点是多个根节点\n      this.children = fragmentNodeData.map((childData) => {\n        const childNode = new Node(this.#generateHTMLFromData(childData));\n        childNode.parent = this;\n        return childNode;\n      });\n    } else {\n      throw new Error(\"无法解析无效的HTML字符串\");\n    }\n  }\n\n  /**\n   * 私有方法：从节点数据生成HTML字符串（用于子节点初始化）\n   * @param {INodeData} nodeData - 节点数据\n   * @returns {string} HTML字符串\n   */\n  #generateHTMLFromData(nodeData: INodeData): string {\n    if (nodeData.tagName === \"#text\") return nodeData.textContent;\n\n    // 构建开始标签\n    let startTag = `<${nodeData.tagName}`;\n    const attrs = { ...nodeData.attributes };\n\n    // 拼接样式属性（覆盖原始style）\n    if (Object.keys(nodeData.styles).length > 0) {\n      const styleStr = Object.entries(nodeData.styles)\n        .map(([key, val]) => `${camelToKebab(key)}: ${val}`)\n        .join(\"; \");\n      attrs.style = styleStr;\n    }\n\n    // 拼接所有属性：过滤内部属性styleObj\n    for (const [key, val] of Object.entries(attrs)) {\n      if (key === \"styleObj\") continue; // 核心修复：跳过内部样式对象属性\n      // 确保val是字符串（IAttributeData中除了styleObj都是string）\n      if (typeof val === \"string\") {\n        startTag += ` ${key}=\"${val}\"`;\n      }\n    }\n\n    // 自闭合标签处理\n    if (SELF_CLOSING_TAGS.includes(nodeData.tagName)) {\n      startTag += \"/>\";\n      return startTag;\n    }\n\n    startTag += \">\";\n\n    // 拼接内容（文本+子节点）\n    let content = nodeData.textContent;\n    if (nodeData.children.length > 0) {\n      content += nodeData.children.map((child) => this.#generateHTMLFromData(child)).join(\"\");\n    }\n\n    return `${startTag}${content}</${nodeData.tagName}>`;\n  }\n\n  /**\n   * 子集管理：获取当前节点的所有子节点\n   * @returns {Node[]} 子节点数组（浅拷贝）\n   */\n  child(): Node[] {\n    return [...this.children];\n  }\n\n  /**\n   * DOM操作：在当前节点之后插入新元素\n   * @param {string|Node} newNode - 要插入的HTML字符串或Node实例\n   * @returns {Node} 当前节点（链式调用）\n   */\n  before(newNode: string | Node): Node {\n    if (!this.parent) {\n      throw new Error(\"当前节点没有父节点，无法执行before操作\");\n    }\n\n    const nodeToInsert = this.#convertToNode(newNode);\n    const currentIndex = this.parent.children.findIndex((child) => child === this);\n\n    if (currentIndex === -1) {\n      throw new Error(\"当前节点不在父节点的子节点列表中\");\n    }\n\n    // 插入到当前节点前一个位置\n    this.parent.children.splice(currentIndex, 0, nodeToInsert);\n    nodeToInsert.parent = this.parent;\n\n    return this;\n  }\n\n  /**\n   * DOM操作：在当前节点之后插入新元素\n   * @param {string|Node} newNode - 要插入的HTML字符串或Node实例\n   * @returns {Node} 当前节点（链式调用）\n   */\n  after(newNode: string | Node): Node {\n    if (!this.parent) {\n      throw new Error(\"当前节点没有父节点，无法执行after操作\");\n    }\n\n    const nodeToInsert = this.#convertToNode(newNode);\n    const currentIndex = this.parent.children.findIndex((child) => child === this);\n\n    if (currentIndex === -1) {\n      throw new Error(\"当前节点不在父节点的子节点列表中\");\n    }\n\n    // 插入到当前节点下一个位置\n    this.parent.children.splice(currentIndex + 1, 0, nodeToInsert);\n    nodeToInsert.parent = this.parent;\n\n    return this;\n  }\n\n  /**\n   * DOM操作：在指定位置插入新元素\n   * @param {number} position - 插入位置（0 ~ children.length）\n   * @param {string|Node} newNode - 要插入的HTML字符串或Node实例\n   * @returns {Node} 当前节点（链式调用）\n   */\n  insert(position: number, newNode: string | Node): Node {\n    if (typeof position !== \"number\" || position < 0 || position > this.children.length) {\n      throw new Error(`插入位置${position}无效，必须是0到${this.children.length}之间的整数`);\n    }\n\n    const nodeToInsert = this.#convertToNode(newNode);\n    // 如果插入的是片段节点，展开其所有子节点（符合DOM标准）\n    if (nodeToInsert.tagName === \"#fragment\") {\n      nodeToInsert.children.forEach((child, index) => {\n        child.parent = this;\n        this.children.splice(position + index, 0, child);\n      });\n    } else {\n      this.children.splice(position, 0, nodeToInsert);\n      nodeToInsert.parent = this;\n    }\n\n    return this;\n  }\n\n  /**\n   * 属性操作：获取指定属性的值\n   * @param {string} attrName - 属性名\n   * @returns {string|null} 属性值（不存在返回null）\n   */\n  getAttr(attrName: string): string | null {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      return null; // 片段/文本节点无属性\n    }\n    if (typeof attrName !== \"string\") {\n      throw new Error(\"属性名必须是字符串\");\n    }\n    // 只返回字符串类型的属性（排除styleObj）\n    return typeof this.attributes[attrName] === \"string\" ? this.attributes[attrName] : null;\n  }\n\n  /**\n   * 属性操作：设置指定属性的值\n   * @param {string} attrName - 属性名\n   * @param {string|null|undefined} value - 属性值（null/undefined删除属性）\n   * @returns {Node} 当前节点（链式调用）\n   */\n  setAttr(attrName: string, value: string | null | undefined): Node {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      throw new Error(\"片段/文本节点不支持设置属性\");\n    }\n    if (typeof attrName !== \"string\") {\n      throw new Error(\"属性名必须是字符串\");\n    }\n\n    if (value === null || value === undefined) {\n      delete this.attributes[attrName];\n    } else {\n      // 确保属性值是字符串（符合IAttributeData的基础约束）\n      this.attributes[attrName] = String(value);\n    }\n\n    return this;\n  }\n\n  /**\n   * 属性操作：批量设置多个属性\n   * @param {Record<string, string | null | undefined>} attrs - 包含属性名-属性值键值对的对象\n   * @returns {Node} 当前节点（链式调用）\n   */\n  setAttrs(attrs: Record<string, string | null | undefined>): Node {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      throw new Error(\"片段/文本节点不支持设置属性\");\n    }\n    if (typeof attrs !== \"object\" || attrs === null) {\n      throw new Error(\"属性对象必须是非空对象\");\n    }\n\n    for (const [attrName, value] of Object.entries(attrs)) {\n      this.setAttr(attrName, value);\n    }\n\n    return this;\n  }\n\n  /**\n   * 样式操作：获取指定样式属性的值\n   * @param {string} styleProp - 样式属性名（支持驼峰/短横线）\n   * @returns {string|null} 样式值（不存在返回null）\n   */\n  getStyle(styleProp: string): string | null {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      return null; // 片段/文本节点无样式\n    }\n    if (typeof styleProp !== \"string\") {\n      throw new Error(\"样式属性名必须是字符串\");\n    }\n\n    const camelProp = kebabToCamel(styleProp);\n    return this.styles[camelProp] || this.styles[styleProp] || null;\n  }\n\n  /**\n   * 样式操作：设置指定样式属性的值\n   * @param {string} styleProp - 样式属性名（支持驼峰/短横线）\n   * @param {string|null|undefined} value - 样式值（null/undefined删除样式）\n   * @returns {Node} 当前节点（链式调用）\n   */\n  setStyle(styleProp: string, value: string | null | undefined): Node {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      throw new Error(\"片段/文本节点不支持设置样式\");\n    }\n    if (typeof styleProp !== \"string\") {\n      throw new Error(\"样式属性名必须是字符串\");\n    }\n\n    const camelProp = kebabToCamel(styleProp);\n    if (value === null || value === undefined) {\n      delete this.styles[camelProp];\n      delete this.styles[styleProp];\n    } else {\n      this.styles[camelProp] = String(value);\n    }\n\n    return this;\n  }\n\n  /**\n   * 样式操作：批量设置多个样式属性\n   * @param {Record<string, string | null | undefined>} styles - 包含样式属性名-样式值键值对的对象\n   * @returns {Node} 当前节点（链式调用）\n   */\n  setStyles(styles: Record<string, string | null | undefined>): Node {\n    if (this.tagName === \"#fragment\" || this.tagName === \"#text\") {\n      throw new Error(\"片段/文本节点不支持设置样式\");\n    }\n    if (typeof styles !== \"object\" || styles === null) {\n      throw new Error(\"样式对象必须是非空对象\");\n    }\n\n    for (const [styleProp, value] of Object.entries(styles)) {\n      this.setStyle(styleProp, value);\n    }\n\n    return this;\n  }\n\n  /**\n   * 获取当前节点的完整HTML文本\n   * @returns {string} HTML字符串\n   */\n  getHtml(): string {\n    // 文本节点直接返回文本\n    if (this.tagName === \"#text\") {\n      return this.textContent;\n    }\n\n    // 片段节点返回所有子节点的HTML拼接\n    if (this.tagName === \"#fragment\") {\n      return this.children.map((child) => child.getHtml()).join(\"\");\n    }\n\n    // 普通元素节点\n    let startTag = `<${this.tagName}`;\n    const attrs = { ...this.attributes };\n\n    // 拼接样式属性（覆盖原始style）\n    if (Object.keys(this.styles).length > 0) {\n      const styleStr = Object.entries(this.styles)\n        .map(([key, val]) => `${camelToKebab(key)}: ${val}`)\n        .join(\"; \");\n      attrs.style = styleStr;\n    }\n\n    // 拼接所有属性：过滤内部属性styleObj，确保值是字符串\n    for (const [key, val] of Object.entries(attrs)) {\n      if (key === \"styleObj\") continue; // 核心修复：跳过内部样式对象属性\n      if (typeof val === \"string\") {\n        const safeVal = val.replace(/\"/g, \"&quot;\");\n        startTag += ` ${key}=\"${safeVal}\"`;\n      }\n    }\n\n    // 自闭合标签处理\n    if (SELF_CLOSING_TAGS.includes(this.tagName)) {\n      startTag += \"/>\";\n      return startTag;\n    }\n\n    startTag += \">\";\n\n    // 拼接内容（文本+子节点HTML）\n    let content = this.textContent;\n    if (this.children.length > 0) {\n      content += this.children.map((child) => child.getHtml()).join(\"\");\n    }\n\n    return `${startTag}${content}</${this.tagName}>`;\n  }\n\n  /**\n   * 私有辅助方法：统一转换插入的节点为Node实例\n   * @param {string|Node} node - HTML字符串或Node实例\n   * @returns {Node} Node实例\n   */\n  #convertToNode(node: string | Node): Node {\n    if (node instanceof Node) return node;\n    if (typeof node === \"string\") return new Node(node);\n    throw new Error(\"插入的节点必须是HTML字符串或Node实例\");\n  }\n}\n\nexport default Node;\n"],"names":["SELF_CLOSING_TAGS","camelToKebab","str","match","kebabToCamel","_","parseAttributes","attrStr","attrs","attrRegex","key","doubleVal","singleVal","noQuoteVal","value","styleObj","styleRegex","styleMatch","prop","val","parseSingleNode","html","selfClosingRegex","selfClosingMatch","tagName","startTagRegex","startTagMatch","startTag","lowerTagName","endTag","endTagIndex","tagCount","currentIndex","nextStart","nextEnd","content","nodeData","childNodes","remaining","tagStart","textNode","tempTagMatch","tempTagName","tempEndTag","selfNode","tempEndIndex","tempTagCount","tempCurrentIndex","nextTempStart","nextTempEnd","childHTML","childNode","parseHTMLFragment","fragmentNodes","Node","htmlTrimmed","singleNodeData","fragmentNodeData","childData","#generateHTMLFromData","styleStr","child","newNode","nodeToInsert","#convertToNode","position","index","attrName","styleProp","camelProp","styles","safeVal","node"],"mappings":"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"}